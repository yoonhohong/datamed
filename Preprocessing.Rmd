---
title: "탐색적 데이터 분석"   
author: "Yoon-Ho Hong" 
date: "2023-08-20"
output: 
  html_document:
    toc: yes
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = F)
```

**내용**   

본격적인 데이터 분석을 하기 전에 거쳐야 할 데이터 전처리는 일반적으로 다음 순서로 이루어집니다. 

- 데이터 정제      
- 데이터 가공    
- 탐색적 데이터분석(exploratory data analysis)                
      
## 데이터 정제

데이터 정제(cleaning)는 보통 다음과 같은 오류를 찾아 제거하거나, 수정하는 과정을 말합니다. 

- 중복값(Duplicates)       
- 부적절한 값(Irrelevant values)      
- 일관되지 않은 값(Inconsistent values)   
- 결축치(Missing values)     
- 극단치(Outliers)         

흔히 데이터 과학자는 데이터 정제에 80%의 시간을 쓰고, 나머지 20%의 시간을 이것에 대해 불평하느라 쓴다는 말이 있습니다. 데이터 정제 과정이 그만큼 오랜 시간과 많은 노력이 드는 작업이라는 뜻입니다.    

우선, 데이터 가공을 먼저 살펴보고, 데이터 정제는 실제 임상 데이터를 다루는 아래 실습 과제에서 좀 더 자세히 살펴보기로 하겠습니다.    


## 데이터 가공       

데이터 가공이란 원시 데이터를 본격적으로 분석하기에 앞서 소프트웨어가 처리할 수 있는 적절한 형식으로 변환하는 과정을 말합니다. 

데이터 가공의 실제를 gapminder 데이터셋을 이용해 살펴보겠습니다.   

gapminder 데이터셋에는 국가별, 년도별 life expectancy, GDP per capita, population 등의 데이터가 포함되어 있습니다.       

gapminder 패키지를 설치하고 로딩하면 작업공간에서 gapminder 데이터를 불러올 수 있습니다.  

```{r}
install.packages("gapminder")
library(gapminder)
```


```{r}
head(gapminder)
str(gapminder)
summary(gapminder)
```

데이터 가공에 필요한 dplyr 패키지를 설치하고, 로딩합니다. 

```{r}
install.packages("dplyr")
library(dplyr)
```

이제부터 데이터 가공에 자주 사용되는 주요 함수들을 하나씩 살펴보겠습니다.   

## select 
특정 변수들만 골라냅니다.   

```{r}
gapminder %>%
  select(continent, country) %>%
  distinct() # return distinct data, removing duplicates  
```

%>% 는 pipe 연산자(operator)이며, 이전(좌측) 결과를 받아서 다음(우측)으로 넘겨 주는 역할을 합니다.   

## filter

조건에 맞는 관측치만 추출합니다.  

```{r}
gapminder %>%
  filter(year == 1957) # 1957년 데이터만 추출합니다.    
```

```{r eval=FALSE}
gapminder %>%
  filter(country == "Korea, Rep.") # Korea, Rep. 데이터만 추출합니다.    
```

## arrange

오름차순으로 정렬합니다.   
```{r eval=FALSE}
gapminder %>%
  arrange(gdpPercap) # gdpPercap 이 낮은 값이서 높은 값으로 정렬합니다. 
```

내림차순으로 정렬하려면 desc() 함수를 사용합니다.   
```{r eval=FALSE}
gapminder %>%
  arrange(desc(gdpPercap)) # 함수 안에서 함수를 사용, nested function 
```

## mutate

변수를 변환해서 새로운 변수를 생성하는 함수입니다.
인구수를 백만명단위로 변환해봅시다.   
```{r eval=FALSE}
gapminder %>%
  mutate(pop = pop/1000000)
```

이번에는 총국민소득을 구해봅시다.   
```{r eval=FALSE}
gapminder %>%
  mutate(gdp = gdpPercap*pop)
```

## summarize
summarize() 함수는 통계 요약치를 구할 때 유용하게 사용됩니다.   
2007년의 평균 기대수명을 구해봅시다.    
```{r eval=FALSE}
gapminder %>%
  filter(year == 2007) %>%
  summarize(meanLifeExp = mean(lifeExp))
```


## group_by

년도별 평균 기대수명을 구해봅시다.   
```{r eval=FALSE}
gapminder %>%
  group_by(year) %>%
  summarise(meanLifeExp = mean(lifeExp))
```

대륙별, 년도별 평균 기대수명을 구해봅시다.      
```{r eval=FALSE}
gapminder %>%
  group_by(continent, year) %>%
  summarize(meanLifeExp = mean(lifeExp))
```

## join 

data frame의 병합을 위해 join 함수를 사용합니다. 
예제를 위해 먼저 병합할 두 개의 data frame 을 만들어보겠습니다. 

```{r}
country = c("Korea", "Japan", "China")
life_exp = c(80, 83, 67)
df1 = data.frame(country, life_exp) 
country = c("Korea", "Japan", "Taiwan")
pop_mil = c(50, 100, 10)
df2 = data.frame(country, pop_mil) 
``` 

```{r}
inner_join(df1, df2, by="country")
left_join(df1, df2, by="country")
right_join(df1, df2, by="country")
full_join(df1, df2, by="country")
```


참고로, vector의 병합을 위해서는 built-in 함수로 intersect, union, setdiff 를 사용합니다.   
```{r}
x = c("a", "b", "c")
y = c("b", "c", "d")
intersect(x, y) # 교집합   
setdiff(x, y) # 여집합  
union(x, y) # 합집합    
```

## reshaping data 

분석에 적합한 형태로 long format <-> wide format 전환이 필요할 때, tidyr 패키지의 gather와 spread 함수를 사용합니다.

```{r eval=FALSE}
install.packages("tidyr")
library(tidyr)
```

```{r}
continent_gapminder <- gapminder %>%
  group_by(continent, year) %>%
  summarise(lifeExp = mean(lifeExp), 
            pop = mean(pop), 
            gdpPercap = mean(gdpPercap))
continent_gapminder %>% 
  gather(key = "attribute", value = "mean", lifeExp:gdpPercap)
```

long format의 데이터 구조를 다시 wide format 으로 바꾸어 봅시다. 

```{r}
long_format = continent_gapminder %>% 
  gather(key = "attribute", value = "mean", lifeExp:gdpPercap)
long_format %>% 
  spread(key = attribute, value = mean)
```



