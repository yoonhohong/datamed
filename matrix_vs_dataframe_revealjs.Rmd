---
title: "R: Matrix vs Data Frame"
date: "2025-08-10"
output:
  revealjs::revealjs_presentation:
    self_contained: true
    transition: "slide"
    center: true
    reveal_options:
      slideNumber: true
      hash: true
      controls: true
      progress: true
---

## 학습 목표
- **matrix**와 **data.frame**의 핵심 차이를 이해한다.  
- 생성/인덱싱/형 변환/연산에서의 동작 차이를 확인한다.  
- 실습 문제로 개념을 점검한다.

## 요약: 무엇이 다른가?
| 구분 | Matrix | Data Frame |
|------|--------|------------|
| **자료형** | 모든 원소 **동일 타입** | 열마다 **서로 다른 타입** 가능 |
| **구성** | 벡터의 2D 확장 | 리스트(list)의 테이블화 |
| **생성** | `matrix()` | `data.frame()` |
| **목적** | 수치/선형대수 연산 | 분석용 표 형식 데이터 |
| **연산** | `%*%`, `t()`, `solve()` 등 | `dplyr::mutate/summarise` 등 |
| **타입 유지** | 혼합시 **강제 형변환(coercion)** | 열별 타입 유지 |

## 1) 생성과 구조
```{r}
# Matrix: 동일 타입 강제
m1 <- matrix(1:6, nrow = 2)  # 2 x 3
m2 <- matrix(c(1, "a", TRUE), nrow = 1)  # 모두 character로 강제
str(m1); m1
str(m2); m2

# Data frame: 열마다 타입 다름
df <- data.frame(name = c("Kim","Lee"),
                 age  = c(30, 25),
                 passed = c(TRUE, FALSE))
str(df); df
```

## 2) 인덱싱 차이 (drop 포함)
```{r}
# Matrix: [row, col], 벡터로 drop됨
m <- matrix(1:9, nrow = 3)
m[1, ]           # 벡터
m[ , 2, drop=FALSE]  # 열을 matrix로 유지

# Data frame: [row, col], 1열만 선택 시 기본은 벡터
df <- data.frame(a = 1:3, b = 4:6)
df[, 1]                 # 벡터
df[, 1, drop = FALSE]   # 데이터프레임 유지
df["a"]                 # 데이터프레임
df[["a"]]               # 벡터
```

## 3) 연산의 차이
```{r}
# Matrix 연산
A <- matrix(1:4, nrow = 2)
B <- matrix(c(2,0,1,2), nrow = 2)
A %*% B           # 행렬곱
t(A)              # 전치
# Data frame은 행렬곱 불가 → 수치 행렬로 변환 필요
as.matrix(df)     # 모두 같은 타입(보통 numeric)일 때만 의미있음
```

## 4) 형 변환과 강제 변환
```{r}
# Data frame -> Matrix
df_num <- data.frame(x = 1:3, y = 4:6)
as.matrix(df_num)       # OK (numeric)

df_mixed <- data.frame(x = 1:3, y = c("a","b","c"))
as.matrix(df_mixed)     # 모든 값이 character로 강제

# Matrix -> Data frame
m <- matrix(1:6, nrow = 3)
as.data.frame(m)
```

## 5) apply vs dplyr
```{r}
# Matrix에서는 apply가 자연스러움
m <- matrix(1:12, nrow = 3)
apply(m, 1, mean)   # 행 평균
apply(m, 2, sum)    # 열 합

# Data frame에서는 dplyr이 자연스러움
library(dplyr)
df <- tibble(g = c("A","A","B"),
             x = c(1,2,3),
             y = c(10,20,30))
df %>% group_by(g) %>% summarise(across(c(x,y), mean))
```

## 6) 실습(5분): 차이 체험
**Q1.** 아래 코드를 실행한 뒤 `str(mix_m)`와 `str(mix_df)`의 차이를 설명하시오.  
**Q2.** `df2`에서 1열만 선택할 때 **벡터가 아닌 data.frame**으로 유지하려면?  
**Q3.** `A %*% B`가 실패한다면, 어떤 변환이 필요할까?

```{r}
mix_m  <- matrix(c(1, "2", TRUE), nrow = 1)
mix_df <- data.frame(a = 1, b = "2", c = TRUE)

df2 <- data.frame(p = 1:3, q = 4:6)

A <- data.frame(a = 1:2, b = 3:4)   # data.frame
B <- data.frame(a = 5:6, b = 7:8)
# 힌트: as.matrix()
```

## 7) 자주 하는 실수 & 교훈
- 서로 다른 타입을 matrix에 넣으면 **전부 character**로 강제됨.  
- data.frame에서 열 선택 시 `df[, 1]`은 **벡터**가 됨 → `drop=FALSE`/`df["col"]`.  
- 행렬 연산은 matrix에서만 가능 → 필요 시 **as.matrix()**.  
- data.frame의 계산은 `dplyr`/`across()`가 가독성과 안정성에서 유리.

## 보너스: 리스트-열(list-column)은?
```{r}
# data.frame/tibble은 열에 리스트를 담을 수 있음(고급기능)
library(tibble)
tbl <- tibble(id = 1:2, lst = list(1:3, letters[1:2]))
str(tbl)
# matrix는 리스트 열을 가질 수 없음(단일 타입 제약)
```

## 요약 정리
- **Matrix**: 동일 타입 2D, 선형대수 중심, `matrix()`, `%*%`, `t()`.  
- **Data Frame**: 열별 타입, 표 데이터 중심, `data.frame()`, `dplyr`.  
- 혼합 타입, 인덱싱 drop, 형 변환에서의 **암묵적 강제(coercion)**에 유의.
